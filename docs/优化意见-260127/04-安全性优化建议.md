# MacJarvis 安全性优化建议

> **文档版本**: v1.0
> **创建日期**: 2026-01-27
> **优化目标**: 构建企业级安全防护体系

---

## 目录

1. [安全威胁分析](#1-安全威胁分析)
2. [认证与授权](#2-认证与授权)
3. [数据安全](#3-数据安全)
4. [工具执行安全](#4-工具执行安全)
5. [API 安全](#5-api-安全)
6. [网络安全](#6-网络安全)
7. [审计与合规](#7-审计与合规)
8. [安全监控](#8-安全监控)

---

## 1. 安全威胁分析

### 1.1 OWASP Top 10 风险评估

| 风险 | 当前状态 | 风险等级 | 优化优先级 |
|------|---------|---------|-----------|
| **注入攻击** | 有风险 | 高 | P0 |
| **身份认证失效** | 无认证 | 严重 | P0 |
| **敏感数据泄露** | 明文存储 | 高 | P0 |
| **XML 外部实体** | 不适用 | - | - |
| **访问控制失效** | 无权限控制 | 高 | P0 |
| **安全配置错误** | 可能存在 | 中 | P1 |
| **跨站脚本(XSS)** | 前端有风险 | 中 | P1 |
| **不安全的反序列化** | 低风险 | 低 | P2 |
| **使用已知漏洞组件** | 未知 | 中 | P1 |
| **日志记录不足** | 不足 | 中 | P1 |

### 1.2 MacJarvis 特有安全风险

⚠️ **系统命令注入**
- 工具执行任意 shell 命令
- 缺乏输入验证
- 无沙箱隔离

⚠️ **文件系统访问**
- 可读写任意文件
- 路径遍历攻击风险
- 敏感文件泄露

⚠️ **LLM 提示词注入**
- 用户可能注入恶意提示词
- 绕过安全限制
- 数据泄露风险

⚠️ **API Key 泄露**
- 环境变量可能泄露
- 日志可能记录敏感信息

---

## 2. 认证与授权

### 2.1 多因素认证 (MFA)

```python
from pyotp import TOTP
import qrcode

class MFAService:
    """多因素认证服务"""

    def enable_mfa(self, user_id: str) -> dict:
        """为用户启用 MFA"""
        # 生成密钥
        secret = pyotp.random_base32()

        # 存储到数据库
        await db.execute(
            update(users)
            .where(users.c.id == user_id)
            .values(mfa_secret=encrypt(secret), mfa_enabled=True)
        )

        # 生成 QR 码
        totp = TOTP(secret)
        uri = totp.provisioning_uri(
            name=user_email,
            issuer_name="MacJarvis"
        )

        qr = qrcode.make(uri)
        qr_path = f"/tmp/qr_{user_id}.png"
        qr.save(qr_path)

        return {
            "secret": secret,
            "qr_code_path": qr_path,
            "backup_codes": self._generate_backup_codes(user_id)
        }

    def verify_mfa(self, user_id: str, code: str) -> bool:
        """验证 MFA 代码"""
        user = await db.execute(
            select(users).where(users.c.id == user_id)
        )
        row = user.fetchone()

        if not row.mfa_enabled:
            return True

        secret = decrypt(row.mfa_secret)
        totp = TOTP(secret)

        # 验证当前代码
        if totp.verify(code, valid_window=1):
            return True

        # 验证备用码
        return await self._verify_backup_code(user_id, code)

    def _generate_backup_codes(self, user_id: str, count: int = 10) -> list[str]:
        """生成备用恢复码"""
        codes = [
            secrets.token_hex(4).upper()
            for _ in range(count)
        ]

        # 哈希后存储
        await db.execute(
            insert(backup_codes).values([
                {
                    "user_id": user_id,
                    "code_hash": bcrypt.hashpw(code.encode(), bcrypt.gensalt()),
                    "used": False
                }
                for code in codes
            ])
        )

        return codes
```

### 2.2 OAuth 2.0 集成

```python
from authlib.integrations.starlette_client import OAuth

oauth = OAuth()

# 配置 OAuth 提供商
oauth.register(
    name='google',
    client_id=settings.GOOGLE_CLIENT_ID,
    client_secret=settings.GOOGLE_CLIENT_SECRET,
    server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
    client_kwargs={'scope': 'openid email profile'}
)

oauth.register(
    name='github',
    client_id=settings.GITHUB_CLIENT_ID,
    client_secret=settings.GITHUB_CLIENT_SECRET,
    authorize_url='https://github.com/login/oauth/authorize',
    access_token_url='https://github.com/login/oauth/access_token',
    client_kwargs={'scope': 'user:email'}
)

@app.get('/auth/{provider}/login')
async def oauth_login(provider: str, request: Request):
    """OAuth 登录"""
    redirect_uri = request.url_for('oauth_callback', provider=provider)
    return await oauth.create_client(provider).authorize_redirect(request, redirect_uri)

@app.get('/auth/{provider}/callback')
async def oauth_callback(provider: str, request: Request):
    """OAuth 回调"""
    client = oauth.create_client(provider)
    token = await client.authorize_access_token(request)
    user_info = await client.parse_id_token(request, token)

    # 创建或更新用户
    user = await get_or_create_user_from_oauth(provider, user_info)

    # 生成 JWT
    access_token = create_access_token(user.id)

    return {"access_token": access_token, "user": user}
```

### 2.3 细粒度权限控制 (RBAC)

```python
from enum import Enum

class Permission(str, Enum):
    # 会话权限
    SESSION_READ = "session:read"
    SESSION_WRITE = "session:write"
    SESSION_DELETE = "session:delete"

    # 工具权限
    TOOL_EXECUTE_BASIC = "tool:execute:basic"
    TOOL_EXECUTE_ADVANCED = "tool:execute:advanced"
    TOOL_EXECUTE_ADMIN = "tool:execute:admin"

    # 文件权限
    FILE_READ = "file:read"
    FILE_WRITE = "file:write"
    FILE_DELETE = "file:delete"

    # 系统权限
    SYSTEM_ADMIN = "system:admin"
    SYSTEM_MONITOR = "system:monitor"

class Role(str, Enum):
    FREE_USER = "free_user"
    PRO_USER = "pro_user"
    ENTERPRISE_USER = "enterprise_user"
    ADMIN = "admin"

# 角色-权限映射
ROLE_PERMISSIONS = {
    Role.FREE_USER: [
        Permission.SESSION_READ,
        Permission.SESSION_WRITE,
        Permission.TOOL_EXECUTE_BASIC,
        Permission.FILE_READ,
    ],
    Role.PRO_USER: [
        Permission.SESSION_READ,
        Permission.SESSION_WRITE,
        Permission.SESSION_DELETE,
        Permission.TOOL_EXECUTE_BASIC,
        Permission.TOOL_EXECUTE_ADVANCED,
        Permission.FILE_READ,
        Permission.FILE_WRITE,
    ],
    Role.ENTERPRISE_USER: [
        # 所有 PRO_USER 权限 +
        Permission.FILE_DELETE,
        Permission.SYSTEM_MONITOR,
    ],
    Role.ADMIN: [Permission(p) for p in Permission],  # 所有权限
}

class PermissionChecker:
    """权限检查器"""

    @staticmethod
    def has_permission(user: User, permission: Permission) -> bool:
        """检查用户是否有指定权限"""
        user_permissions = ROLE_PERMISSIONS.get(user.role, [])
        return permission in user_permissions

    @staticmethod
    def require_permission(permission: Permission):
        """装饰器：要求特定权限"""
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                # 从请求中获取用户
                request = kwargs.get("request") or args[0]
                user = request.state.user

                if not PermissionChecker.has_permission(user, permission):
                    raise HTTPException(
                        status_code=403,
                        detail=f"Permission denied: {permission}"
                    )

                return await func(*args, **kwargs)
            return wrapper
        return decorator

# 使用示例
@app.delete("/api/sessions/{session_id}")
@PermissionChecker.require_permission(Permission.SESSION_DELETE)
async def delete_session(session_id: str, request: Request):
    # 只有有删除权限的用户才能执行
    await session_service.delete(session_id)
    return {"ok": True}
```

---

## 3. 数据安全

### 3.1 数据加密

#### 传输加密 (TLS)

```nginx
# Nginx TLS 配置
server {
    listen 443 ssl http2;
    server_name macjarvis.com;

    # 证书配置
    ssl_certificate /etc/letsencrypt/live/macjarvis.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/macjarvis.com/privkey.pem;

    # TLS 协议
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;

    # 加密套件（只使用强加密）
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';

    # HSTS（强制 HTTPS）
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

    # 其他安全头
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';" always;
}

# 强制重定向 HTTP 到 HTTPS
server {
    listen 80;
    server_name macjarvis.com;
    return 301 https://$server_name$request_uri;
}
```

#### 静态数据加密

```python
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2

class EncryptionService:
    """数据加密服务"""

    def __init__(self, master_key: str):
        # 从主密钥派生加密密钥
        kdf = PBKDF2(
            algorithm=hashes.SHA256(),
            length=32,
            salt=b'macjarvis_salt_v1',  # 应该随机生成并安全存储
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(master_key.encode()))
        self.cipher = Fernet(key)

    def encrypt(self, plaintext: str) -> str:
        """加密数据"""
        return self.cipher.encrypt(plaintext.encode()).decode()

    def decrypt(self, ciphertext: str) -> str:
        """解密数据"""
        return self.cipher.decrypt(ciphertext.encode()).decode()

# 使用示例
encryption = EncryptionService(settings.MASTER_KEY)

# 加密敏感字段
class User(BaseModel):
    id: str
    email: str
    api_key_encrypted: str  # 加密存储

    @property
    def api_key(self) -> str:
        """解密 API Key"""
        return encryption.decrypt(self.api_key_encrypted)

    @api_key.setter
    def api_key(self, value: str):
        """加密并存储 API Key"""
        self.api_key_encrypted = encryption.encrypt(value)

# 数据库级别加密（PostgreSQL）
# CREATE EXTENSION IF NOT EXISTS pgcrypto;
#
# CREATE TABLE secrets (
#     id UUID PRIMARY KEY,
#     user_id UUID NOT NULL,
#     key VARCHAR(255) NOT NULL,
#     value BYTEA NOT NULL,  -- 加密存储
#     created_at TIMESTAMP NOT NULL DEFAULT NOW()
# );
#
# -- 插入时加密
# INSERT INTO secrets (id, user_id, key, value)
# VALUES (gen_random_uuid(), ?, ?, pgp_sym_encrypt(?, 'encryption_key'));
#
# -- 查询时解密
# SELECT id, key, pgp_sym_decrypt(value, 'encryption_key') AS value
# FROM secrets WHERE user_id = ?;
```

### 3.2 密钥管理

使用 HashiCorp Vault 管理密钥：

```python
import hvac

class VaultClient:
    """Vault 客户端"""

    def __init__(self, url: str, token: str):
        self.client = hvac.Client(url=url, token=token)

    def get_secret(self, path: str) -> dict:
        """获取密钥"""
        response = self.client.secrets.kv.v2.read_secret_version(path=path)
        return response['data']['data']

    def set_secret(self, path: str, data: dict):
        """设置密钥"""
        self.client.secrets.kv.v2.create_or_update_secret(
            path=path,
            secret=data
        )

    def rotate_secret(self, path: str, new_value: str):
        """轮换密钥"""
        # 1. 读取当前值
        current = self.get_secret(path)

        # 2. 备份旧值
        self.set_secret(f"{path}_backup", current)

        # 3. 设置新值
        self.set_secret(path, {"value": new_value, "rotated_at": datetime.utcnow().isoformat()})

# 使用示例
vault = VaultClient(
    url="http://vault:8200",
    token=os.getenv("VAULT_TOKEN")
)

# 获取数据库密码
db_password = vault.get_secret("database/postgres")["password"]

# 获取 OpenAI API Key
openai_key = vault.get_secret("api_keys/openai")["key"]
```

### 3.3 敏感数据脱敏

```python
class DataMasker:
    """数据脱敏"""

    @staticmethod
    def mask_email(email: str) -> str:
        """脱敏邮箱"""
        local, domain = email.split('@')
        if len(local) <= 2:
            masked_local = local[0] + '*'
        else:
            masked_local = local[0] + '*' * (len(local) - 2) + local[-1]
        return f"{masked_local}@{domain}"

    @staticmethod
    def mask_api_key(key: str) -> str:
        """脱敏 API Key"""
        if len(key) <= 8:
            return '*' * len(key)
        return key[:4] + '*' * (len(key) - 8) + key[-4:]

    @staticmethod
    def mask_credit_card(card: str) -> str:
        """脱敏信用卡号"""
        card = card.replace('-', '').replace(' ', '')
        return '*' * (len(card) - 4) + card[-4:]

# 使用在日志中
logger.info(f"User {DataMasker.mask_email(user.email)} logged in")
logger.info(f"Using API key {DataMasker.mask_api_key(api_key)}")
```

---

## 4. 工具执行安全

### 4.1 命令注入防护

```python
import shlex
from pathlib import Path

class SecureCommandRunner:
    """安全的命令执行器"""

    # 命令白名单
    ALLOWED_COMMANDS = {
        "ls", "cat", "pwd", "whoami", "date",
        "system_profiler", "diskutil", "networksetup"
    }

    # 危险命令黑名单
    BLOCKED_COMMANDS = {
        "rm", "rmdir", "dd", "mkfs", "sudo", "su",
        "shutdown", "reboot", "kill", "killall"
    }

    def __init__(self):
        self.validator = CommandValidator()

    async def run(
        self,
        command: list[str],
        timeout: int = 30
    ) -> dict:
        """安全执行命令"""
        # 1. 验证命令
        if not self._is_command_safe(command):
            return {
                "ok": False,
                "error": "Command not allowed"
            }

        # 2. 参数转义
        escaped_command = [shlex.quote(arg) for arg in command]

        # 3. 在沙箱中执行
        try:
            result = await self._run_in_sandbox(
                escaped_command,
                timeout=timeout
            )
            return {"ok": True, "data": result}
        except Exception as e:
            return {"ok": False, "error": str(e)}

    def _is_command_safe(self, command: list[str]) -> bool:
        """检查命令是否安全"""
        if not command:
            return False

        cmd_name = command[0].split('/')[-1]  # 提取命令名

        # 检查黑名单
        if cmd_name in self.BLOCKED_COMMANDS:
            logger.warning(f"Blocked command: {cmd_name}")
            return False

        # 检查白名单
        if cmd_name not in self.ALLOWED_COMMANDS:
            logger.warning(f"Unknown command: {cmd_name}")
            return False

        # 检查参数中的危险模式
        args_str = ' '.join(command[1:])
        dangerous_patterns = [
            ';', '&&', '||', '|', '>', '<', '`', '$(',  # 命令连接
            '../', '~/',  # 路径遍历
            '${', '$(', '``',  # 变量展开
        ]

        for pattern in dangerous_patterns:
            if pattern in args_str:
                logger.warning(f"Dangerous pattern in args: {pattern}")
                return False

        return True

    async def _run_in_sandbox(
        self,
        command: list[str],
        timeout: int
    ) -> str:
        """在 Docker 沙箱中执行命令"""
        # 使用 Docker 容器隔离执行
        docker_command = [
            "docker", "run", "--rm",
            "--network", "none",  # 禁用网络
            "--memory", "256m",    # 内存限制
            "--cpus", "0.5",       # CPU 限制
            "--read-only",         # 只读文件系统
            "--tmpfs", "/tmp",     # 临时文件系统
            "--security-opt", "no-new-privileges",  # 禁止提权
            "--cap-drop", "ALL",   # 移除所有 capabilities
            "alpine:latest",       # 基础镜像
            *command
        ]

        process = await asyncio.create_subprocess_exec(
            *docker_command,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )

        try:
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )
            return stdout.decode() or stderr.decode()
        except asyncio.TimeoutError:
            process.kill()
            raise TimeoutError(f"Command timeout after {timeout}s")
```

### 4.2 文件访问控制

```python
class SecureFileAccess:
    """安全的文件访问"""

    # 允许访问的目录白名单
    ALLOWED_ROOTS = [
        Path.home() / "Documents",
        Path.home() / "Desktop",
        Path.home() / "Downloads",
        Path("/tmp/macjarvis"),
    ]

    # 禁止访问的路径
    BLOCKED_PATHS = [
        Path.home() / ".ssh",
        Path.home() / ".aws",
        Path("/etc/passwd"),
        Path("/etc/shadow"),
        Path("/System"),
    ]

    # 禁止的文件扩展名
    BLOCKED_EXTENSIONS = {
        ".exe", ".app", ".dmg", ".pkg",  # 可执行文件
        ".sh", ".bash", ".zsh",          # 脚本文件
        ".key", ".pem", ".p12",          # 密钥文件
    }

    @classmethod
    def validate_path(cls, path: str | Path) -> Path:
        """验证路径安全性"""
        path = Path(path).resolve()  # 解析符号链接和相对路径

        # 1. 检查是否在允许的根目录下
        is_allowed = any(
            path.is_relative_to(root)
            for root in cls.ALLOWED_ROOTS
        )
        if not is_allowed:
            raise PermissionError(f"Path not in allowed roots: {path}")

        # 2. 检查是否在黑名单中
        for blocked in cls.BLOCKED_PATHS:
            if path == blocked or path.is_relative_to(blocked):
                raise PermissionError(f"Access denied to: {path}")

        # 3. 检查文件扩展名
        if path.suffix.lower() in cls.BLOCKED_EXTENSIONS:
            raise PermissionError(f"File type not allowed: {path.suffix}")

        return path

    @classmethod
    async def read_file(
        cls,
        path: str,
        max_size: int = 10 * 1024 * 1024  # 10MB
    ) -> str:
        """安全读取文件"""
        validated_path = cls.validate_path(path)

        # 检查文件大小
        if validated_path.stat().st_size > max_size:
            raise ValueError(f"File too large (max {max_size} bytes)")

        # 读取文件
        async with aiofiles.open(validated_path, 'r') as f:
            content = await f.read()

        # 检测敏感信息
        if cls._contains_sensitive_data(content):
            logger.warning(f"Sensitive data detected in {path}")
            # 可以选择拒绝或脱敏

        return content

    @classmethod
    async def write_file(
        cls,
        path: str,
        content: str,
        max_size: int = 5 * 1024 * 1024  # 5MB
    ):
        """安全写入文件"""
        validated_path = cls.validate_path(path)

        # 检查内容大小
        if len(content.encode()) > max_size:
            raise ValueError(f"Content too large (max {max_size} bytes)")

        # 检查是否覆盖现有文件
        if validated_path.exists():
            # 备份现有文件
            backup_path = validated_path.with_suffix(
                validated_path.suffix + '.bak'
            )
            shutil.copy2(validated_path, backup_path)

        # 写入文件
        async with aiofiles.open(validated_path, 'w') as f:
            await f.write(content)

    @staticmethod
    def _contains_sensitive_data(content: str) -> bool:
        """检测敏感数据"""
        patterns = [
            r'(?i)password\s*[:=]\s*\S+',
            r'(?i)api[_-]?key\s*[:=]\s*\S+',
            r'(?i)secret\s*[:=]\s*\S+',
            r'\b[A-Za-z0-9]{32,}\b',  # 长字符串（可能是密钥）
            r'\b(?:sk|pk)_[a-zA-Z0-9]{32,}\b',  # Stripe keys
        ]

        for pattern in patterns:
            if re.search(pattern, content):
                return True

        return False
```

---

## 5. API 安全

### 5.1 速率限制

```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(
    key_func=get_remote_address,
    storage_uri="redis://localhost:6379"
)

app = FastAPI()
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# 全局限流
@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    # 获取用户 ID（如果已认证）
    user_id = getattr(request.state, "user_id", None)

    if user_id:
        # 用户级别限流
        key = f"rate_limit:user:{user_id}"
        limit = await get_user_rate_limit(user_id)
    else:
        # IP 级别限流
        key = f"rate_limit:ip:{request.client.host}"
        limit = 100  # 匿名用户每小时 100 次

    # 检查限流
    current = await redis.incr(key)
    if current == 1:
        await redis.expire(key, 3600)  # 1小时窗口

    if current > limit:
        raise HTTPException(
            status_code=429,
            detail={
                "error": "Rate limit exceeded",
                "limit": limit,
                "reset_at": (datetime.utcnow() + timedelta(hours=1)).isoformat()
            }
        )

    response = await call_next(request)
    response.headers["X-RateLimit-Limit"] = str(limit)
    response.headers["X-RateLimit-Remaining"] = str(max(0, limit - current))

    return response

# 端点级别限流
@app.post("/api/chat")
@limiter.limit("30/minute")  # 每分钟 30 次
async def chat_endpoint(request: Request):
    # ...
    pass
```

### 5.2 输入验证

```python
from pydantic import BaseModel, validator, Field
import bleach

class ChatRequest(BaseModel):
    message: str = Field(..., min_length=1, max_length=10000)
    session_id: str = Field(..., regex=r'^[a-zA-Z0-9_-]+$')
    model: str = Field(default="gpt-4o-mini")

    @validator('message')
    def sanitize_message(cls, v):
        """清理消息内容"""
        # 移除 HTML 标签
        v = bleach.clean(v, tags=[], strip=True)

        # 检测注入攻击
        dangerous_patterns = [
            r'<script',
            r'javascript:',
            r'onerror=',
            r'onclick=',
        ]
        for pattern in dangerous_patterns:
            if re.search(pattern, v, re.IGNORECASE):
                raise ValueError("Potentially malicious content detected")

        return v

    @validator('model')
    def validate_model(cls, v):
        """验证模型名称"""
        allowed_models = [
            "gpt-4o-mini",
            "gpt-4o",
            "claude-3-5-sonnet"
        ]
        if v not in allowed_models:
            raise ValueError(f"Model not allowed: {v}")
        return v

# SQL 注入防护（使用参数化查询）
# ❌ 不安全
query = f"SELECT * FROM users WHERE email = '{email}'"  # SQL 注入风险

# ✅ 安全
query = "SELECT * FROM users WHERE email = ?"
result = await db.execute(query, email)
```

### 5.3 CSRF 防护

```python
from starlette.middleware.cors import CORSMiddleware
from starlette_csrf import CSRFMiddleware

# CORS 配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://macjarvis.com",
        "https://app.macjarvis.com"
    ],  # 不要使用 "*"
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
    max_age=3600,
)

# CSRF 中间件
app.add_middleware(
    CSRFMiddleware,
    secret=settings.CSRF_SECRET,
    cookie_secure=True,  # 只通过 HTTPS
    cookie_httponly=True,
    cookie_samesite="lax"
)

# 前端需要在请求头中包含 CSRF Token
# const csrfToken = document.cookie.match(/csrftoken=([^;]+)/)?.[1];
# fetch('/api/chat', {
#   method: 'POST',
#   headers: {
#     'X-CSRFToken': csrfToken,
#   },
#   body: JSON.stringify(data)
# });
```

---

## 6. 网络安全

### 6.1 DDoS 防护

```nginx
# Nginx 配置
http {
    # 限制并发连接数
    limit_conn_zone $binary_remote_addr zone=addr:10m;
    limit_conn addr 10;

    # 限制请求速率
    limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s;
    limit_req zone=one burst=20 nodelay;

    server {
        # SYN Flood 防护
        listen 80 default_server backlog=2048;

        # 超时设置
        client_body_timeout 10s;
        client_header_timeout 10s;
        send_timeout 10s;

        # 请求大小限制
        client_max_body_size 10M;
        client_body_buffer_size 128k;

        # 阻止未知 User-Agent
        if ($http_user_agent ~* (bot|crawler|spider) ) {
            return 403;
        }
    }
}
```

使用 Cloudflare 或 AWS Shield：

```yaml
# Cloudflare 防护设置
cloudflare:
  - 启用 "Under Attack Mode" (紧急情况)
  - 配置 WAF 规则
  - 启用 Rate Limiting
  - 配置 Bot Management
```

### 6.2 IP 白名单/黑名单

```python
class IPFilter:
    """IP 过滤器"""

    def __init__(self, redis: Redis):
        self.redis = redis

    async def is_blocked(self, ip: str) -> bool:
        """检查 IP 是否被封禁"""
        return await self.redis.sismember("blocked_ips", ip)

    async def block_ip(self, ip: str, duration: int = 3600):
        """封禁 IP"""
        await self.redis.sadd("blocked_ips", ip)
        await self.redis.expire(f"blocked:{ip}", duration)
        logger.warning(f"Blocked IP: {ip}")

    async def is_whitelisted(self, ip: str) -> bool:
        """检查 IP 是否在白名单"""
        return await self.redis.sismember("whitelisted_ips", ip)

# 中间件
@app.middleware("http")
async def ip_filter_middleware(request: Request, call_next):
    ip = request.client.host

    # 检查黑名单
    if await ip_filter.is_blocked(ip):
        raise HTTPException(status_code=403, detail="IP blocked")

    # 检查白名单（管理员 IP）
    is_admin_route = request.url.path.startswith("/admin")
    if is_admin_route and not await ip_filter.is_whitelisted(ip):
        raise HTTPException(status_code=403, detail="Admin access denied")

    return await call_next(request)
```

---

## 7. 审计与合规

### 7.1 审计日志

```python
from enum import Enum

class AuditAction(str, Enum):
    USER_LOGIN = "user.login"
    USER_LOGOUT = "user.logout"
    SESSION_CREATE = "session.create"
    SESSION_DELETE = "session.delete"
    TOOL_EXECUTE = "tool.execute"
    FILE_READ = "file.read"
    FILE_WRITE = "file.write"
    FILE_DELETE = "file.delete"
    PERMISSION_CHANGE = "permission.change"
    CONFIG_CHANGE = "config.change"

class AuditLogger:
    """审计日志记录器"""

    def __init__(self, db: Database):
        self.db = db

    async def log(
        self,
        action: AuditAction,
        user_id: str,
        resource_type: str,
        resource_id: str,
        details: dict | None = None,
        ip_address: str | None = None,
        user_agent: str | None = None
    ):
        """记录审计日志"""
        await self.db.execute(
            insert(audit_logs).values(
                id=generate_id(),
                timestamp=datetime.utcnow(),
                action=action,
                user_id=user_id,
                resource_type=resource_type,
                resource_id=resource_id,
                details=json.dumps(details) if details else None,
                ip_address=ip_address,
                user_agent=user_agent
            )
        )

    async def query_logs(
        self,
        user_id: str | None = None,
        action: AuditAction | None = None,
        start_date: datetime | None = None,
        end_date: datetime | None = None,
        limit: int = 100
    ) -> list[dict]:
        """查询审计日志"""
        query = select(audit_logs)

        if user_id:
            query = query.where(audit_logs.c.user_id == user_id)
        if action:
            query = query.where(audit_logs.c.action == action)
        if start_date:
            query = query.where(audit_logs.c.timestamp >= start_date)
        if end_date:
            query = query.where(audit_logs.c.timestamp <= end_date)

        query = query.order_by(audit_logs.c.timestamp.desc()).limit(limit)

        result = await self.db.execute(query)
        return result.fetchall()

# 使用示例
audit = AuditLogger(db)

# 记录工具执行
await audit.log(
    action=AuditAction.TOOL_EXECUTE,
    user_id=user.id,
    resource_type="tool",
    resource_id=tool_name,
    details={"args": args, "result": result},
    ip_address=request.client.host,
    user_agent=request.headers.get("user-agent")
)

# 查询用户操作历史
logs = await audit.query_logs(
    user_id=user.id,
    start_date=datetime.utcnow() - timedelta(days=7)
)
```

### 7.2 GDPR 合规

```python
class GDPRService:
    """GDPR 合规服务"""

    async def export_user_data(self, user_id: str) -> dict:
        """导出用户数据（GDPR 权利）"""
        # 1. 用户基本信息
        user = await db.users.find_one({"_id": user_id})

        # 2. 会话数据
        sessions = await db.sessions.find({"user_id": user_id}).to_list(None)

        # 3. 审计日志
        audit_logs = await db.audit_logs.find({"user_id": user_id}).to_list(None)

        # 4. 打包导出
        export_data = {
            "user": user,
            "sessions": sessions,
            "audit_logs": audit_logs,
            "exported_at": datetime.utcnow().isoformat()
        }

        # 生成导出文件
        file_path = f"/tmp/user_data_{user_id}.json"
        with open(file_path, 'w') as f:
            json.dump(export_data, f, indent=2)

        return {"file_path": file_path}

    async def delete_user_data(self, user_id: str):
        """删除用户数据（被遗忘权）"""
        # 1. 软删除用户
        await db.execute(
            update(users)
            .where(users.c.id == user_id)
            .values(
                is_active=False,
                deleted_at=datetime.utcnow(),
                email=f"deleted_{user_id}@example.com",  # 匿名化
                api_key_encrypted=None
            )
        )

        # 2. 删除会话
        await db.sessions.delete_many({"user_id": user_id})

        # 3. 匿名化审计日志（保留但不关联用户）
        await db.execute(
            update(audit_logs)
            .where(audit_logs.c.user_id == user_id)
            .values(user_id="<deleted>")
        )

        logger.info(f"Deleted all data for user {user_id}")

    async def anonymize_old_data(self, days: int = 365):
        """匿名化旧数据"""
        cutoff_date = datetime.utcnow() - timedelta(days=days)

        # 匿名化旧审计日志
        await db.execute(
            update(audit_logs)
            .where(audit_logs.c.timestamp < cutoff_date)
            .values(
                ip_address="0.0.0.0",
                user_agent="<anonymized>"
            )
        )
```

---

## 8. 安全监控

### 8.1 入侵检测

```python
class IntrusionDetector:
    """入侵检测系统"""

    def __init__(self, redis: Redis):
        self.redis = redis

    async def detect_brute_force(self, user_id: str, ip: str) -> bool:
        """检测暴力破解"""
        key = f"login_attempts:{ip}:{user_id}"
        attempts = await self.redis.incr(key)

        if attempts == 1:
            await self.redis.expire(key, 900)  # 15分钟窗口

        if attempts > 5:
            # 触发告警
            await self.alert("Brute force detected", {
                "user_id": user_id,
                "ip": ip,
                "attempts": attempts
            })
            return True

        return False

    async def detect_anomaly(self, user_id: str, action: str):
        """检测异常行为"""
        # 获取用户正常行为基线
        baseline = await self.get_user_baseline(user_id)

        # 检测异常
        current_rate = await self.get_action_rate(user_id, action)
        if current_rate > baseline.get(action, 0) * 5:  # 超过5倍
            await self.alert("Anomalous behavior detected", {
                "user_id": user_id,
                "action": action,
                "current_rate": current_rate,
                "baseline": baseline.get(action)
            })

    async def alert(self, message: str, data: dict):
        """发送安全告警"""
        # 发送到 Slack/Email/PagerDuty
        logger.critical(f"SECURITY ALERT: {message}", extra=data)

        # 存储到数据库
        await db.execute(
            insert(security_alerts).values(
                timestamp=datetime.utcnow(),
                severity="critical",
                message=message,
                data=json.dumps(data)
            )
        )
```

### 8.2 安全扫描

```bash
#!/bin/bash
# security_scan.sh

echo "Running security scans..."

# 1. 依赖漏洞扫描
echo "Scanning Python dependencies..."
pip-audit

# 2. 代码安全扫描
echo "Scanning code for security issues..."
bandit -r src/

# 3. 密钥泄露扫描
echo "Scanning for leaked secrets..."
trufflehog filesystem . --json

# 4. Docker 镜像扫描
echo "Scanning Docker images..."
trivy image macjarvis-backend:latest
trivy image macjarvis-frontend:latest

# 5. 基础设施扫描
echo "Scanning infrastructure..."
checkov -d .

echo "Security scan complete"
```

---

## 总结

安全优化要点：

1. **认证授权**: MFA、OAuth、RBAC
2. **数据安全**: TLS、加密、密钥管理
3. **工具安全**: 沙箱隔离、命令白名单、路径验证
4. **API 安全**: 速率限制、输入验证、CSRF 防护
5. **网络安全**: DDoS 防护、IP 过滤
6. **审计合规**: 审计日志、GDPR 合规
7. **安全监控**: 入侵检测、漏洞扫描

**安全是持续过程，需要定期审查和更新！**
